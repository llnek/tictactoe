// Generated by CoffeeScript 1.4.0

require([
  "use!jquery",
  "use!underscore",
  "use!backbone",
],
function($,_,Backbone,undefined) {
"use strict";
function _isx(obj) { return typeof obj !== 'undefined' && obj !== null; }
var C_BG=0,
C_UI=1,
C_GAME=2,
C_CELL_WIDTH=60,
C_GRIDCLR='#fff',
O_CLR= '#8ADE35',
X_CLR= '#F59631';


;

var Circle, Line, TextStyle, TicTacToe;

Circle = (function() {

  function Circle(x, y, radius) {
    this.x = x;
    this.y = y;
    this.radius = radius;
  }

  Circle.prototype.draw = function(ctx, styleObj) {
    ctx.beginPath();
    ctx.strokeStyle = styleObj.stroke.style;
    ctx.lineWidth = styleObj.line.width;
    ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI, true);
    return ctx.stroke();
  };

  return Circle;

})();

Line = (function() {

  function Line(x1, y1, x2, y2) {
    this.x1 = x1;
    this.y1 = y1;
    this.x2 = x2;
    this.y2 = y2;
  }

  Line.prototype.draw = function(ctx, styleObj) {
    ctx.beginPath();
    ctx.moveTo(this.x1, this.y1);
    ctx.lineTo(this.x2, this.y2);
    ctx.strokeStyle = styleObj.stroke.style;
    ctx.lineWidth = styleObj.line.width;
    if (styleObj.line.cap != null) {
      ctx.lineCap = styleObj.line.cap;
    }
    return ctx.stroke();
  };

  return Line;

})();

TextStyle = (function() {

  function TextStyle() {
    this.font = "14px 'Architects Daughter'";
    this.fill = "#dddddd";
    this.align = "left";
    this.base = "top";
  }

  return TextStyle;

})();

TicTacToe = (function() {

  function TicTacToe(size, players) {
    this.size = size != null ? size : 3;
    this.players = players != null ? players : 1;
    this.cells = this.size * this.size;
    this.X = this.size * -1;
    this.O = this.size;
    this.layers = _.map(['bg', 'ui', 'game'], function(v) {
      return $('#tictactoe #' + v)[0].getContext('2d');
    });
    this.mapGoalSpace();
  }

  TicTacToe.prototype.cls = function(ctx) {
    return ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
  };

  TicTacToe.prototype.loadAssets = function() {
    var dfd, me, nok, ok;
    dfd = $.Deferred();
    me = this;
    nok = function(msg) {
      return alert('dude, no good\n' + msg);
    };
    ok = function() {
      return me.build();
    };
    this.scoreX = 0;
    this.scoreO = 0;
    this.bgImg = new Image();
    this.bgImg.onerror = function() {
      return dfd.reject('Error while loading background image');
    };
    this.bgImg.onload = function() {
      return dfd.resolve();
    };
    this.bgImg.src = '/public/images/bg.png';
    return $.when(dfd.promise()).then(ok, nok);
  };

  TicTacToe.prototype.inizEvents = function() {
    var em, me;
    em = $('#tictactoe #layers');
    me = this;
    em.mousedown(function(ev) {
      return me.onLeftMouseDown(ev);
    });
    $('#tictactoe #play').on('click', function() {
      return me.onPlay();
    });
    return $('#tictactoe #stop').on('click', function() {
      return me.onStop();
    });
  };

  TicTacToe.prototype.build = function() {
    this.showBackdrop();
    this.inizEvents();
    return this.readyForGame();
  };

  TicTacToe.prototype.readyForGame = function() {
    this.gameInProgress = false;
    this.maybeEnableInputs();
    this.clsArena();
    return this.showMsg('Ready for a quick game with our Cyborg? ');
  };

  TicTacToe.prototype.onLeftMouseDown = function(ev) {
    var mX, mY, res, _ref;
    if (this.gameInProgress && this.curActor === this.X) {
      _ref = this.offset(ev), mX = _ref[0], mY = _ref[1];
      res = this.checkOffset(mX, mY);
      if (_isx(res)) {
        return this.checkInput(res);
      }
    }
  };

  TicTacToe.prototype.onPlay = function() {
    var a, cb, me;
    if (this.gameInProgress !== true) {
      me = this;
      this.gameInProgress = true;
      this.level = parseInt($('#tictactoe #level').val(), 10);
      this.inizGameData();
      this.clsArena();
      this.maybeDisableInputs();
      a = this.curActor === this.X ? 'You move' : 'Cyborg moves';
      this.showMsg("Game Started! " + a + " first ...");
      cb = function() {
        if (me.curActor === me.O) {
          return me.cyborgMove();
        }
      };
      return this.syncPlayerState(cb);
    }
  };

  TicTacToe.prototype.onStop = function() {
    if (this.gameInProgress === true) {
      this.gameInProgress = false;
      if (this.curActor === this.X) {
        return this.onStopReset();
      }
    }
  };

  TicTacToe.prototype.onStopReset = function() {
    this.nukeGame();
    return this.showMsg('Game stopped.  Play a New Game ? ');
  };

  TicTacToe.prototype.nukeGame = function() {
    this.gameInProgress = false;
    this.maybeEnableInputs();
    return this.clsStates();
  };

  TicTacToe.prototype.checkWin = function() {
    var winner;
    winner = this.findWinner();
    if (winner === this.X || winner === this.O || winner === 911) {
      return this.endGame(winner);
    } else {
      return this.toggleActor();
    }
  };

  TicTacToe.prototype.findWinner = function() {
    var i, p, sum, winner, _i, _j, _k, _l, _ref, _ref1, _ref2, _ref3;
    sum = 0;
    for (i = _i = 0, _ref = this.cells; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      sum += this.grid[i];
      if (((i + 1) % this.size) === 0) {
        winner = this.matchXO(sum);
        if (_isx(winner)) {
          return winner;
        } else {
          sum = 0;
        }
      }
    }
    for (i = _j = 0, _ref1 = this.size; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
      sum = 0;
      p = i;
      while (p < this.cells) {
        sum += this.grid[p];
        p += this.size;
      }
      winner = this.matchXO(sum);
      if (_isx(winner)) {
        return winner;
      }
    }
    sum = 0;
    for (i = _k = 0, _ref2 = this.dx.length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
      sum += this.grid[this.dx[i]];
    }
    winner = this.matchXO(sum);
    if (_isx(winner)) {
      return winner;
    }
    sum = 0;
    for (i = _l = 0, _ref3 = this.dy.length; 0 <= _ref3 ? _l < _ref3 : _l > _ref3; i = 0 <= _ref3 ? ++_l : --_l) {
      sum += this.grid[this.dy[i]];
    }
    winner = this.matchXO(sum);
    if (_isx(winner)) {
      return winner;
    }
    if (_.include(this.grid, 0)) {
      return null;
    } else {
      return 911;
    }
  };

  TicTacToe.prototype.matchXO = function(sum) {
    switch (sum) {
      case this.X:
        return this.X;
      case this.O:
        return this.O;
      default:
        return null;
    }
  };

  TicTacToe.prototype.syncPlayerState = function(cb) {
    var ctx, msg, x, xc, xh, y, _ref;
    _ref = this.clsStates(), ctx = _ref[0], y = _ref[1], xh = _ref[2], xc = _ref[3];
    this.styleText(ctx, new TextStyle());
    if (this.curActor === this.X) {
      msg = 'Your Turn...';
      x = xh;
    } else {
      msg = 'Thinking...';
      x = xc;
    }
    return setTimeout(function() {
      ctx.fillText(msg, x, y);
      return cb();
    }, 500);
  };

  TicTacToe.prototype.clsStates = function() {
    var ctx, xc, xh, _y;
    ctx = this.layers[C_GAME];
    xc = this.gX + this.size * C_CELL_WIDTH + 25;
    xh = this.gX - 120;
    _y = this.gY - 10;
    ctx.clearRect(xc, _y, 120, 64);
    ctx.clearRect(xh, _y, 120, 64);
    return [ctx, this.gY, xh, xc];
  };

  TicTacToe.prototype.showBackdrop = function() {
    var ctx;
    ctx = this.layers[C_BG];
    this.cls(ctx);
    return ctx.drawImage(this.bgImg, 0, 0);
  };

  TicTacToe.prototype.drawMisc = function() {
    var ctx, w, y;
    ctx = this.layers[C_UI];
    w = 120;
    y = 64;
    this.drawMiscEx(ctx, 'Human ', '#ddd', this.gX - w, y, '"X"', X_CLR);
    return this.drawMiscEx(ctx, 'Cyborg ', '#ddd', this.gX + this.size * C_CELL_WIDTH + 25, y, '"O"', O_CLR);
  };

  TicTacToe.prototype.drawMiscEx = function(ctx, preText, c1, x, y, postText, c2) {
    var w;
    ctx.font = "14px 'Architects Daughter'";
    ctx.lineWidth = 2;
    ctx.fillStyle = c1;
    ctx.textAlign = "left";
    ctx.textBaseline = "bottom";
    w = ctx.measureText(preText).width;
    ctx.fillText(preText, x, y);
    ctx.fillStyle = c2;
    return ctx.fillText(postText, x + w, y);
  };

  TicTacToe.prototype.drawGrid = function() {
    var ctx, i, side, styleObj, x, x1, x2, y, y1, y2, _i, _ref, _results;
    ctx = this.layers[C_UI];
    ctx.strokeStyle = C_GRIDCLR;
    ctx.lineWidth = 1;
    side = this.size * C_CELL_WIDTH;
    x = (ctx.canvas.width - side) / 2;
    y = 100;
    ctx.strokeRect(x, y, side, side);
    this.gX = x;
    this.gY = y;
    styleObj = {
      stroke: {
        style: C_GRIDCLR
      },
      line: {
        width: 1
      }
    };
    _results = [];
    for (i = _i = 1, _ref = this.size; 1 <= _ref ? _i < _ref : _i > _ref; i = 1 <= _ref ? ++_i : --_i) {
      x1 = x + i * C_CELL_WIDTH;
      y1 = y;
      x2 = x1;
      y2 = y1 + side;
      new Line(x1, y1, x2, y2).draw(ctx, styleObj);
      y1 = y + i * C_CELL_WIDTH;
      x1 = x;
      x2 = x1 + side;
      y2 = y1;
      _results.push(new Line(x1, y1, x2, y2).draw(ctx, styleObj));
    }
    return _results;
  };

  TicTacToe.prototype.endGame = function(winner) {
    var msg;
    switch (winner) {
      case this.X:
        msg = 'Human Wins!';
        break;
      case this.O:
        msg = 'Cyborg Wins!';
        break;
      default:
        msg = "It's a draw!";
    }
    msg = msg + ' Play again?';
    this.updateScoreBoard(winner);
    this.nukeGame();
    return this.showMsg(msg);
  };

  TicTacToe.prototype.updateScoreBoard = function(winner) {
    var em, s, val;
    switch (winner) {
      case this.X:
        this.scoreX += 1;
        val = this.scoreX;
        em = $('#scoreX');
        break;
      case this.O:
        this.scoreO += 1;
        val = this.scoreO;
        em = $('#scoreO');
        break;
      default:
        return;
    }
    s = val < 10 ? '00' : val < 100 ? '0' : '';
    s = s + val;
    return em.text(s);
  };

  TicTacToe.prototype.checkInput = function(res) {
    var c;
    c = res[2];
    if (this.grid[c] !== 0) {
      return this.showMsg('Invalid move, try again!');
    } else {
      this.grid[c] = this.curActor === this.X ? -1 : 1;
      this.drawCell(res);
      return this.checkWin();
    }
  };

  TicTacToe.prototype.showMsg = function(msg) {
    var ctx, x, y;
    ctx = this.layers[C_GAME];
    ctx.font = "14px 'Architects Daughter'";
    ctx.fillStyle = "#dddddd";
    ctx.textAlign = "left";
    ctx.textBaseline = "bottom";
    x = this.gX - 120;
    y = this.gY + this.size * C_CELL_WIDTH + 64;
    ctx.clearRect(x, y - 36, 400, 36);
    return ctx.fillText(msg, x, y);
  };

  TicTacToe.prototype.checkOffset = function(x, y) {
    var col, i, p, q, row, _i, _ref;
    col = -1;
    row = -1;
    p = this.gX;
    q = this.gY;
    /*
        console.log('gX='+p)
        console.log('gY='+q)
        console.log('x='+x)
        console.log('y='+y)
    */

    for (i = _i = 0, _ref = this.size; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      if (x > p && x < (p + C_CELL_WIDTH)) {
        col = i;
      }
      if (y > q && y < (q + C_CELL_WIDTH)) {
        row = i;
      }
      p += C_CELL_WIDTH;
      q += C_CELL_WIDTH;
    }
    if (col >= 0 && row >= 0) {
      return [row, col, row * this.size + col];
    } else {
      return null;
    }
  };

  TicTacToe.prototype.offset = function(ev) {
    var mX, mY, os;
    os = $('#tictactoe #layers').offset();
    mX = ev.pageX - os.left;
    mY = ev.pageY - os.top;
    return [mX, mY];
  };

  TicTacToe.prototype.drawCell = function(res) {
    var col, ctx, r, row, styleObj, x, x1, x2, y, y1, y2;
    ctx = this.layers[C_GAME];
    row = res[0];
    col = res[1];
    x1 = this.gX + col * C_CELL_WIDTH;
    y1 = this.gY + row * C_CELL_WIDTH;
    x2 = x1 + C_CELL_WIDTH;
    y2 = y1 + C_CELL_WIDTH;
    x = (x2 - x1) / 2;
    y = (y2 - y1) / 2;
    r = C_CELL_WIDTH / 2 - 8;
    styleObj = {
      stroke: {
        style: C_GRIDCLR
      },
      line: {
        width: 3
      }
    };
    if (this.grid[res[2]] === -1) {
      styleObj.stroke.style = X_CLR;
      styleObj.line.cap = 'round';
      new Line(x1 + x - r, y1 + y - r, x1 + x + r, y1 + y + r, 3).draw(ctx, styleObj);
      return new Line(x1 + x + r, y1 + y - r, x1 + x - r, y1 + y + r, 3).draw(ctx, styleObj);
    } else {
      styleObj.stroke.style = O_CLR;
      return new Circle(x1 + x, y1 + y, r, 3).draw(ctx, styleObj);
    }
  };

  TicTacToe.prototype.maybeEnableInputs = function() {
    return $('#tictactoe #level').removeAttr('disabled');
  };

  TicTacToe.prototype.maybeDisableInputs = function() {
    return $('#tictactoe #level').attr('disabled', 'disabled');
  };

  TicTacToe.prototype.clsArena = function() {
    this.cls(this.layers[C_GAME]);
    this.cls(this.layers[C_UI]);
    this.drawGrid();
    return this.drawMisc();
  };

  TicTacToe.prototype.inizGameData = function() {
    var i, _i, _j, _k, _ref, _ref1, _ref2, _results;
    this.curActor = Math.floor(Math.random() * 10) > 5 ? this.X : this.O;
    this.grid = [];
    this.dx = [];
    this.dy = [];
    for (i = _i = 0, _ref = this.cells; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      this.grid[i] = 0;
    }
    for (i = _j = 0, _ref1 = this.size; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
      this.dx[i] = 0;
      this.dy[i] = 0;
    }
    this.dx[0] = this.size - 1;
    this.dy[0] = 0;
    _results = [];
    for (i = _k = 1, _ref2 = this.size; 1 <= _ref2 ? _k < _ref2 : _k > _ref2; i = 1 <= _ref2 ? ++_k : --_k) {
      this.dx[i] = this.dx[i - 1] + this.size - 1;
      _results.push(this.dy[i] = this.dy[i - 1] + this.size + 1);
    }
    return _results;
  };

  TicTacToe.prototype.toggleActor = function() {
    var cb, me;
    this.curActor = this.curActor === this.X ? this.O : this.X;
    me = this;
    cb = function() {
      if (me.curActor === me.O) {
        return setTimeout(function() {
          return me.cyborgMove();
        }, 2000);
      }
    };
    return this.syncPlayerState(cb);
  };

  TicTacToe.prototype.cyborgMove = function() {
    switch (this.level) {
      case 1:
        return this.cyborgCasual();
      case 2:
        return this.cyborgNormal();
      case 3:
        return this.cyborg();
    }
  };

  TicTacToe.prototype.cyborgCasual = function() {
    /*
        first check through and see if borg is poised to win by 1 move,
        if so, do it.  otherwise, just randomly make a move
    */
    if (!this.scanForEasyWin()) {
      return this.randomMove();
    }
  };

  TicTacToe.prototype.cyborgNormal = function() {
    /*
        a bit smarter than casual, knows how to block,defend!
    */
    if (!this.scanForEasyWin()) {
      if (!this.defendNeeded()) {
        return this.randomMove();
      }
    }
  };

  TicTacToe.prototype.cyborg = function() {
    /*
        smarter than normal, knows how to attack
    */
    if (!this.scanForEasyWin()) {
      if (!this.defendNeeded()) {
        return this.calcBestMove();
      }
    }
  };

  TicTacToe.prototype.cyborgMakesMove = function(cell) {
    if (this.gameInProgress === false) {
      return this.onStopReset();
    } else {
      this.grid[cell] = 1;
      this.drawCell(this.cellToRC(cell));
      return this.checkWin();
    }
  };

  TicTacToe.prototype.defendNeeded = function() {
    var cb, defend, i, me, _i, _ref;
    defend = this.level < 3 ? Math.floor(Math.random() * 10) > 5 : true;
    if (defend) {
      me = this;
      cb = function(pz) {
        return me.cyborgMakesMove(pz);
      };
      for (i = _i = 0, _ref = this.GOALSPACE.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (this.poisedToWin(this.GOALSPACE[i], this.X + 1, cb)) {
          return true;
        }
      }
    }
    return false;
  };

  TicTacToe.prototype.calcBestMove = function() {
    /*
        try corners, center
    */

    var c, i, len, pz, _i, _j, _ref, _ref1;
    c = [];
    for (i = _i = 0, _ref = this.dx.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      if (this.grid[this.dx[i]] === 0) {
        c.push(this.dx[i]);
      }
    }
    for (i = _j = 0, _ref1 = this.dy.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
      if (this.grid[this.dy[i]] === 0) {
        c.push(this.dy[i]);
      }
    }
    len = c.length;
    if (len > 0) {
      pz = c[Math.floor(Math.random() * len)];
      return this.cyborgMakesMove(pz);
    } else {
      return this.randomMove();
    }
  };

  TicTacToe.prototype.randomMove = function() {
    var p;
    p = this.nextFreeCell();
    if (p === -1) {
      return this.endGame(911);
    } else {
      return this.cyborgMakesMove(p);
    }
  };

  TicTacToe.prototype.scanForEasyWin = function() {
    var cb, i, me, _i, _ref;
    me = this;
    cb = function(pz) {
      return me.cyborgMakesMove(pz);
    };
    for (i = _i = 0, _ref = this.GOALSPACE.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      if (this.poisedToWin(this.GOALSPACE[i], this.O - 1, cb)) {
        return true;
      }
    }
    return false;
  };

  TicTacToe.prototype.poisedToWin = function(goal, target, cb) {
    var i, me, pz, sum, v, _i, _ref;
    pz = -1;
    sum = 0;
    me = this;
    for (i = _i = 0, _ref = goal.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      v = this.grid[goal[i]];
      sum += v;
      if (v === 0) {
        pz = goal[i];
      }
    }
    if (sum === target) {
      setTimeout(function() {
        return cb(pz);
      }, 0);
      return true;
    } else {
      return false;
    }
  };

  TicTacToe.prototype.cellToRC = function(cell) {
    return [Math.floor(cell / this.size), cell % this.size, cell];
  };

  TicTacToe.prototype.nextFreeCell = function() {
    var free, len, pos;
    free = [];
    _.each(this.grid, function(v, i) {
      if (v === 0) {
        return free.push(i);
      }
    });
    len = free.length;
    pos = Math.floor(Math.random() * len);
    if (len === 0) {
      return -1;
    } else {
      return free[pos];
    }
  };

  TicTacToe.prototype.mapGoalSpace = function() {
    var c, i, p, _i, _j, _k, _l, _ref, _ref1, _ref2, _ref3;
    this.GOALSPACE = [];
    c = [];
    for (i = _i = 0, _ref = this.cells; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      c.push(i);
      if (((i + 1) % this.size) === 0) {
        this.GOALSPACE.push(c);
        c = [];
      }
    }
    c = [];
    for (i = _j = 0, _ref1 = this.size; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
      p = i;
      while (p < this.cells) {
        c.push(p);
        p += this.size;
      }
      this.GOALSPACE.push(c);
      c = [];
    }
    c = [];
    c[0] = this.size - 1;
    for (i = _k = 1, _ref2 = this.size; 1 <= _ref2 ? _k < _ref2 : _k > _ref2; i = 1 <= _ref2 ? ++_k : --_k) {
      c[i] = c[i - 1] + this.size - 1;
    }
    this.GOALSPACE.push(c);
    c = [];
    c[0] = 0;
    for (i = _l = 1, _ref3 = this.size; 1 <= _ref3 ? _l < _ref3 : _l > _ref3; i = 1 <= _ref3 ? ++_l : --_l) {
      c[i] = c[i - 1] + this.size + 1;
    }
    this.GOALSPACE.push(c);
    return c = [];
  };

  TicTacToe.prototype.styleText = function(ctx, styleObj) {
    ctx.font = styleObj.font;
    ctx.fillStyle = styleObj.fill;
    ctx.textAlign = styleObj.align;
    ctx.textBaseline = styleObj.base;
    return ctx;
  };

  TicTacToe.prototype.run = function() {
    return this.loadAssets();
  };

  return TicTacToe;

})();



$(function(){
  new TicTacToe(3,1).run();
});

});


;

